---
title: "Stan Practice"
author: "Ali Campbell"
date: "1/13/2021"
output: html_document
---

```{r setup, include=FALSE}
library(rstanarm)
library(brms)  # for models
library(tidyverse)
library(rstan)
library(StanHeaders)
library(shinystan)
library(bayesplot)
library(devtools)
library(tidyr)
library(lattice)
library(lme4)
library(dplyr)
library(tidyverse)
library(nnet)
library(fixest)
library(mlogit)
library(dfidx)
library(effects)
library(bbmle)
library(magrittr)
library(Gmisc)
library(RColorBrewer)
library(ggeffects)
library(heplots)
#library(sjPlot)
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores())
setwd("/Users/alicampbell/Box Sync/Grad/Cactus/Shared Code/ant_cactus_demography/Stan")
```

#### Data

```{r}
data <- data.frame(cactus$volume_t, cactus$volume_t1, cactus$ant_t, cactus$Goodbuds_t, cactus$Goodbuds_t1, cactus$ABFlowerbuds_t, cactus$ABFlowerbuds_t1, cactus$TotFlowerbuds_t, cactus$TotFlowerbuds_t1, cactus$Survival_t1)
data <- na.omit(data)
colnames(data) <- c("volume_t","volume_t1", "ant_t", "Goodbuds_t", "Goodbuds_t1", "ABFlowerbuds_t", "ABFlowerbuds_t1", "TotFlowerbuds_t", "TotFlowerbuds_t1", "Survival_t1")
```

## Basic Models (No Ant Effects)
```{r Growth Model}
## Now rename variables and index
x <- log(data$volume_t)
y <- log(data$volume_t1)
N <- length(data$volume_t)
## Rerun linear model with that new data
#mod1 <- lm(y~x, data = data)
#summary(grow_model)
#summary(mod1)
## Now we can extract some important statistics
lm_alpha <- summary(grow_model)$coeff[1]  # the intercept
lm_beta <- summary(grow_model)$coeff[2]  # the slope
lm_sigma <- sigma(grow_model)  # the residual error
## Make it a dataframe
stan_data <- list(N = N, x = x, y = y)
## Write the model in stan
#note that we are using flat priors here which are non restrictive
write("// Stan model for simple linear regression

data {
 int < lower = 1 > N; // Sample size
 vector[N] x; // Predictor
 vector[N] y; // Outcome
}

parameters {
 real alpha; // Intercept
 real beta; // Slope (regression coefficients)
 real < lower = 0 > sigma; // Error SD
}

model {
// Priors
alpha ~ normal(0,100);
beta ~ normal(0,100); 
//sigma ~ exponential(0,0);
 y ~ normal(alpha + x * beta , sigma); // The Model
}

generated quantities {
} // The posterior predictive distribution",

"grow_lm1.stan")
## Check that you wrote a file
#stanc("grow_lm1.stan")
## Save the file path
stanny <- "grow_lm1.stan"
## Now we fit the model
fit <- stan(file = stanny, data = stan_data, warmup = 500, iter = 1000, chains = 4, cores = 2, thin = 1)
fit

par(mfrow = c(1,3))

plot(density(posterior$alpha), main = "Alpha")
abline(v = lm_alpha, col = 4, lty = 2)

plot(density(posterior$beta), main = "Beta")
abline(v = lm_beta, col = 4, lty = 2)

plot(density(posterior$sigma), main = "Sigma")
abline(v = lm_sigma, col = 4, lty = 2)
```

These appear pretty good. Roughly centered around the previous estimates. 

```{r Total Flowers}
x <- log(data$volume_t)
y <- data$TotFlowerbuds_t
N <- length(data$volume_t)
## Rerun linear model with that new data
#mod1 <- lm(y~x, data = data)
summary(flower_model)
#summary(mod1)
## Now we can extract some important statistics
lm_lambda = mean(data$TotFlowerbuds_t)
## Make it a dataframe
stan_data <- list(N = N, x = x, y = y)
## Write the model in stan
#note that we are using flat priors here which are non restrictive
write("// Stan model for simple linear regression

data {
 int N;
 real x[N];
 int y[N];
}
parameters {
 real<lower = 0> lambda;
}
model {
// Priors
 lambda ~ cauchy(0, 1);
 //lambda ~ gamma(0, 0);
 // Model
 y ~ poisson(lambda);
}
",

"flower_lm1.stan")
## Check that you wrote a file
stanc("flower_lm1.stan")
## Save the file path
stanny <- "flower_lm1.stan"
## Now we fit the model
fit <- stan(file = stanny, data = stan_data, warmup = 500, iter = 1000, chains = 4, cores = 2, thin = 1)
fit

##plot(density(posterior$lambda), main = "Lambda")
##abline(v = lm_lambda, col = 4, lty = 2)
```

```{r Survival}
x <- log(data$volume_t)
y <- data$Survival_t1
N <- length(data$volume_t)
#import things from the r regression models for comparison
lm_alpha <- summary(surv_model)$coeff[1]  # the intercept
lm_beta <- summary(surv_model)$coeff[2]  # the slope
summary(surv_model)
## Make it a dataframe
stan_data <- list(N = N, x = x, y = y)
## Write the model in stan
#note that we are using flat priors here which are non restrictive
write("// Stan model for simple linear regression

data {
  int<lower=0> N;
  vector[N] x;
  int<lower=0,upper=1> y[N];
}
parameters {
  real alpha;
  real beta;
}
model {
  y ~ bernoulli_logit(alpha + beta * x);
}
",

"survr_lm1.stan")
## Check that you wrote a file
stanc("surv_lm1.stan")
## Save the file path
stanny <- "surv_lm1.stan"
## Now we fit the model
fit <- stan(file = stanny, data = stan_data, warmup = 500, iter = 1000, chains = 4, cores = 2, thin = 1)
fit

par(mfrow = c(1,2))

plot(density(posterior$alpha), main = "Alpha")
abline(v = lm_alpha, col = 4, lty = 2)

plot(density(posterior$beta), main = "Beta")
abline(v = lm_beta, col = 4, lty = 2)
```


#### Mixed models
```{r}
## Write in Data
data <- data.frame(cactus$volume_t, cactus$volume_t1, cactus$ant_t, cactus$TotFlowerbuds_t)
data <- na.omit(data)
colnames(data) <- c("volume_t","volume_t1", "ant_t", "TotFlowerbuds_t", "Survival_t1")
## Write the models in
totflow_stan_mixex_ant <- stan_glmer(TotFlowerbuds_t ~log(volume_t) + (1|ant_t), family = "poisson", data = cactus, chains = 4, cores = 4)
totflow_stan_mixed_ant_interact <- stan_glmer(TotFlowerbuds_t ~log(volume_t)*(1|ant_t), family = "poisson", data = cactus, chains = 4, cores = 4)
## Now check AIC values
AIC(totflow_stan)
AIC(totflow_stan_ant)
AIC(totflow_stan_ant_interact)
#Note that all of these say 0
## Check convergence
plot(totflow_stan, plotfun = "trace")
plot(totflow_stan_ant, plotfun = "trace")
plot(totflow_stan_ant_interact, plotfun = "trace")

##Now Code it in stan
write("// Stan model for simple linear regression

data {
  int<lower=1> N;            //number of observations
  real RT[N];                //reaction times

  int<lower=0,upper=9> Days[N];   //predictor (days of sleep deprivation)

  // grouping factor
  int<lower=1> J;                   //number of subjects
  int<lower=1,upper=J> Subject[N];  //subject id
}

parameters {
  vector[2] beta;                   // fixed-effects parameters
  real<lower=0> sigma_e;            // residual std
  vector<lower=0>[2] sigma_u;       // random effects standard deviations

  // declare L_u to be the Choleski factor of a 2x2 correlation matrix
  cholesky_factor_corr[2] L_u;

  matrix[2,J] z_u;                  // random effect matrix
}

transformed parameters {
  // this transform random effects so that they have the correlation
  // matrix specified by the correlation matrix above
  matrix[2,J] u;
  u = diag_pre_multiply(sigma_u, L_u) * z_u;

}

model {
  real mu; // conditional mean of the dependent variable

  //priors
  L_u ~ lkj_corr_cholesky(1.5); // LKJ prior for the correlation matrix
  to_vector(z_u) ~ normal(0,2);
  sigma_e ~ normal(0, 5);       // prior for residual standard deviation
  beta[1] ~ normal(0.3, 0.5);   // prior for fixed-effect intercept
  beta[2] ~ normal(0.2, 2);     // prior for fixed-effect slope

  //likelihood
  for (i in 1:N){
    mu = beta[1] + u[1,Subject[i]] + (beta[2] + u[2,Subject[i]])*Days[i];
    RT[i] ~ normal(mu, sigma_e);
  }
} // The posterior predictive distribution

generated quantities {
  matrix[2, 2] Omega;
  Omega = L_u * L_u'; // so that it return the correlation matrix
}",

"totflow_mixed1.stan")

stan_model1 <- "totflow_mixed1.stan"
## Now we fit the model
fit <- stan(file = stan_model1, data = stan_data, warmup = 500, iter = 1000, chains = 4, cores = 2, thin = 1)
fit
```
