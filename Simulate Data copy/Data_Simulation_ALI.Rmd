---
title: "Simulate the Models"
author: "Ali Campbell"
date: "12/13/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
```

###Growth model

```{r}
#Model:
grow_model_ant_interact
#Simulated Data:
coefs <- mvrnorm(n = 10000, mu = coefficients(grow_model_ant_interact), Sigma = vcov(grow_model_ant_interact))
plot(grow_model_ant_interact)

##Check this against original model
#Simulated Coefficients
colMeans(coefs)
#Original Coefficients
coefficients(grow_model_ant_interact)
#These are pretty similar, so I will now look at standard errors
#Simulated Standard Error
apply(coefs, 2, sd)
#Original Standard Error
sqrt(diag(vcov(grow_model_ant_interact)))
#These are also pretty good. So now we simulate the data


##simulate the data
sim.dat <- matrix(nrow = n, ncol = nrow(coefs))
mod.mat <- model.matrix(grow_model_ant_interact)
for (i in 1:nrow(coefs)) {
  sim.dat[, i] <- rpois(n, exp(mod.mat %*% coefs[i, ]))
}
rm(i, mod.mat)
##Now we compare the simualted and original variance and mean
#Simulated mean and var
c(mean(colMeans(sim.dat)), mean(apply(sim.dat, 2, var)))
#Original mean and var
c(mean(cactus$volume_t1,na.rm=TRUE), var(cactus$volume_t1,na.rm = TRUE))
```

The variance is not that far off
The mean is significantly different. This to me indicates that likely the model is not a good one

```{r}
# This is were I run the model
# This is a gaussian model, but you can change the family to be poisson or whatever
grow_model_ant_interact <- glm(formula = log(volume_t1) ~ log(volume_t) * ant_t, data = cactus, family = "gaussian")
anova(grow_model_ant_interact, test = "Chisq")
summary(grow_model_ant_interact)
# plot(infl_mod)

# This is our simulated predictor data
min(cactus$volume_t, na.rm = T)
newdat1<- data.frame(volume_t = seq(log(0.1),log(3129321),0.002076463), ant_t = "crem")
newdat2 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "liom")
newdat3 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "vacant")
newdat4 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "other")
newdat <- rbind(newdat1, newdat1, newdat2, newdat3)

# use the predict function for to get the model output
# note that terms is for a linear model and response is for a binomial model
y_pred <- predict(grow_model_ant_interact, newdata = newdat, type = "terms")
y_CI <- predict(grow_model_ant_interact, newdata = newdat, interval = "confidence", type = "link", se.fit=TRUE)

#This is one way to pull out the link function automatically from the fitted object
linkinv <- family(grow_model_ant_interact)$linkinv ## inverse-link function

# you can also define your own link function, which is useful for stuff like Stan, where you just get posterior draws, and not a R model object
# and so for my other project, where I have categorical data, I define these functions at the top of the script
# invlogit<-function(x){exp(x)/(1+exp(x))}
# and then use that transform the model predictions to the appropriate scale
# I think for poisson, you can use exp() to exponentiate the results

#Now make a dataframe that combines all the predictions and confidence intervals
newpred <- newdat
newpred$pred0 <- y_CI$fit
newpred$pred <- linkinv(y_CI$fit) #This is the link function
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
sc2 <- abs(qnorm((1-alpha2)/2))  ## Normal approx. to likelihood
newpred <- transform(newpred,
                     lwr=linkinv(pred0-sc*y_CI$se.fit),
                     upr=linkinv(pred0+sc*y_CI$se.fit),
                     lwr2=linkinv(pred0-sc2*y_CI$se.fit),
                     upr2=linkinv(pred0+sc2*y_CI$se.fit))

# Then you can plot it
ggplot() + 
  geom_point(data = cactus, aes(x = log(volume_t), y = volume_t1, pch = as.factor(ant_t)), color = "#4c90dd", lwd = 2) + 
  geom_line(data = newpred, aes(x = volume_t, y = pred, group = ant_t, linetype = as.factor(ant_t))) +
  geom_ribbon(data = newpred, aes(x = volume_t, ymin = lwr, ymax = upr, group = ant_t, fill = as.factor(ant_t)), alpha = .2) 
  #geom_smooth(data=cactus, aes(y=Survival_t1, x=log(volume_t), col=ant_t), method = "glm", formula='y~x', method.args = list(family = "binomial"), se = TRUE) 
  #geom_smooth(data = cactus, aes(x = log(volume_t), y = Survival_t1, pch = as.factor(ant_t)))
```

###Survival Model
```{r}
# This is were I run the model
# This is a gaussian model, but you can change the family to be poisson or whatever
surv_model_ant_interact
anova(surv_model_ant_interact, test = "Chisq")
summary(surv_model_ant_interact)
# plot(infl_mod)

# This is our simulated predictor data
min(cactus$volume_t, na.rm = T)
newdat1<- data.frame(volume_t = seq(log(0.1),log(3129321),0.002076463), ant_t = "crem")
newdat2 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "liom")
newdat3 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "vacant")
newdat4 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "other")
newdat <- rbind(newdat1, newdat1, newdat2, newdat3)

# use the predict function for to get the model output
y_pred <- predict(surv_model_ant_interact, newdata = newdat, type = "response")
y_CI <- predict(surv_model_ant_interact, newdata = newdat, interval = "confidence", type = "link", se.fit=TRUE)

#This is one way to pull out the link function automatically from the fitted object
linkinv <- family(surv_model_ant_interact)$linkinv ## inverse-link function

# you can also define your own link function, which is useful for stuff like Stan, where you just get posterior draws, and not a R model object
# and so for my other project, where I have categorical data, I define these functions at the top of the script
# invlogit<-function(x){exp(x)/(1+exp(x))}
# and then use that transform the model predictions to the appropriate scale
# I think for poisson, you can use exp() to exponentiate the results

#Now make a dataframe that combines all the predictions and confidence intervals
newpred <- newdat
newpred$pred0 <- y_CI$fit
newpred$pred <- linkinv(y_CI$fit) #This is the link function
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
sc2 <- abs(qnorm((1-alpha2)/2))  ## Normal approx. to likelihood
newpred <- transform(newpred,
                     lwr=linkinv(pred0-sc*y_CI$se.fit),
                     upr=linkinv(pred0+sc*y_CI$se.fit),
                     lwr2=linkinv(pred0-sc2*y_CI$se.fit),
                     upr2=linkinv(pred0+sc2*y_CI$se.fit))

# Then you can plot it
ggplot() + 
  geom_point(data = cactus, aes(x = log(volume_t), y = Survival_t1, pch = as.factor(ant_t)), color = "#4c90dd", lwd = 2) + 
  geom_line(data = newpred, aes(x = volume_t, y = pred, group = ant_t, linetype = as.factor(ant_t))) +
  geom_ribbon(data = newpred, aes(x = volume_t, ymin = lwr, ymax = upr, group = ant_t, fill = as.factor(ant_t)), alpha = .2) 
  #geom_smooth(data=cactus, aes(y=Survival_t1, x=log(volume_t), col=ant_t), method = "glm", formula='y~x', method.args = list(family = "binomial"), se = TRUE) 
  #geom_smooth(data = cactus, aes(x = log(volume_t), y = Survival_t1, pch = as.factor(ant_t)))
```


###Viable Model (OKAY. I DO NOT KNOW HOW TO SIMULATE THIS ONE. AT ALL. PLEASE HELP)
```{r}
# This is were I run the model
# This is a gaussian model, but you can change the family to be poisson or whatever
abort_model_ant
anova(abort_model_ant, test = "Chisq")
summary(abort_model_ant)
# plot(infl_mod)

# This is our simulated predictor data
min(cactus$volume_t, na.rm = T)
newdat1<- data.frame(volume_t = seq(log(0.1),log(3129321),0.002076463), ant_t = "crem")
newdat2 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "liom")
newdat3 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "vacant")
newdat4 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "other")
newdat <- rbind(newdat1, newdat1, newdat2, newdat3)

# use the predict function for to get the model output
y_pred <- predict(abort_model_ant, newdata = newdat, type = "response")
y_CI <- predict(abort_model_ant, newdata = newdat, interval = "confidence", type = "link", se.fit=TRUE)

#This is one way to pull out the link function automatically from the fitted object
linkinv <- family(abort_model_ant)$linkinv ## inverse-link function

# you can also define your own link function, which is useful for stuff like Stan, where you just get posterior draws, and not a R model object
# and so for my other project, where I have categorical data, I define these functions at the top of the script
# invlogit<-function(x){exp(x)/(1+exp(x))}
# and then use that transform the model predictions to the appropriate scale
# I think for poisson, you can use exp() to exponentiate the results

#Now make a dataframe that combines all the predictions and confidence intervals
newpred <- newdat
newpred$pred0 <- y_CI$fit
newpred$pred <- linkinv(y_CI$fit) #This is the link function
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
sc2 <- abs(qnorm((1-alpha2)/2))  ## Normal approx. to likelihood
newpred <- transform(newpred,
                     lwr=linkinv(pred0-sc*y_CI$se.fit),
                     upr=linkinv(pred0+sc*y_CI$se.fit),
                     lwr2=linkinv(pred0-sc2*y_CI$se.fit),
                     upr2=linkinv(pred0+sc2*y_CI$se.fit))

# Then you can plot it
ggplot() + 
  geom_point(data = cactus, aes(x = ant_t, y = cbind(Goodbuds_t,ABFlowerbuds_t), pch = as.factor(ant_t)), color = "#4c90dd", lwd = 2) +
  geom_line(data = newpred, aes(x = ant_t, y = pred, group = ant_t, linetype = as.factor(ant_t))) +
  geom_ribbon(data = newpred, aes(x = ant_t, ymin = lwr, ymax = upr, group = ant_t, fill = as.factor(ant_t)), alpha = .2) 
  #geom_smooth(data=cactus, aes(y=Survival_t1, x=log(volume_t), col=ant_t), method = "glm", formula='y~x', method.args = list(family = "binomial"), se = TRUE) 
  #geom_smooth(data = cactus, aes(x = log(volume_t), y = Survival_t1, pch = as.factor(ant_t)))
```

```{r}
#Model:
abort_model_ant
#Simulated Data:
coefs <- mvrnorm(n = 10000, mu = coefficients(abort_model_ant), Sigma = vcov(abort_model_ant))

##Check this against original model
#Simulated Coefficients
colMeans(coefs)
#Original Coefficients
coefficients(abort_model_ant)
#These are pretty similar, so I will now look at standard errors
#Simulated Standard Error
apply(coefs, 2, sd)
#Original Standard Error
sqrt(diag(vcov(abort_model_ant)))
#These are also pretty good. So now we simulate the data


##simulate the data
sim.dat <- matrix(nrow = n, ncol = nrow(coefs))
mod.mat <- model.matrix(abort_model_ant)
for (i in 1:nrow(coefs)) {
  sim.dat[, i] <- rpois(n, exp(mod.mat %*% coefs[i, ]))
}
rm(i, mod.mat)

#Now we compare the simualted and original variance and mean
#Simulated mean and var
c(mean(colMeans(sim.dat)), mean(apply(sim.dat, 2, var)))
#Original mean and var
x <- cbind(cactus$Goodbuds_t, cactus$ABFlowerbuds_t)
c(mean(x,na.rm=TRUE), var(x,na.rm = TRUE))
```
Sooooo, This is not quite right. Clearly. 

###Reproductive State
```{r}
# This is were I run the model
# This is a gaussian model, but you can change the family to be poisson or whatever
repro_model_ant
anova(repro_model_ant, test = "Chisq")
summary(repro_model_ant)
plot(repro_model_ant)

# This is our simulated predictor data
min(cactus$volume_t, na.rm = T)
newdat1<- data.frame(volume_t = seq(log(0.1),log(3129321),0.002076463), ant_t = "crem")
newdat2 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "liom")
newdat3 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "vacant")
newdat4 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "other")
newdat <- rbind(newdat1, newdat1, newdat2, newdat3)

# use the predict function for to get the model output
y_pred <- predict(repro_model_ant, newdata = newdat, type = "response")
y_CI <- predict(repro_model_ant, newdata = newdat, interval = "confidence", type = "link", se.fit=TRUE)

#This is one way to pull out the link function automatically from the fitted object
linkinv <- family(repro_model_ant)$linkinv ## inverse-link function

# you can also define your own link function, which is useful for stuff like Stan, where you just get posterior draws, and not a R model object
# and so for my other project, where I have categorical data, I define these functions at the top of the script
# invlogit<-function(x){exp(x)/(1+exp(x))}
# and then use that transform the model predictions to the appropriate scale
# I think for poisson, you can use exp() to exponentiate the results

#Now make a dataframe that combines all the predictions and confidence intervals
newpred <- newdat
newpred$pred0 <- y_CI$fit
newpred$pred <- linkinv(y_CI$fit) #This is the link function
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
sc2 <- abs(qnorm((1-alpha2)/2))  ## Normal approx. to likelihood
newpred <- transform(newpred,
                     lwr=linkinv(pred0-sc*y_CI$se.fit),
                     upr=linkinv(pred0+sc*y_CI$se.fit),
                     lwr2=linkinv(pred0-sc2*y_CI$se.fit),
                     upr2=linkinv(pred0+sc2*y_CI$se.fit))

# Then you can plot it
ggplot() + 
  geom_point(data = cactus, aes(x = log(volume_t), y = repro_state_t, pch = as.factor(ant_t)), color = "#4c90dd", lwd = 2) + 
  geom_line(data = newpred, aes(x = volume_t, y = pred, group = ant_t, linetype = as.factor(ant_t))) +
  geom_ribbon(data = newpred, aes(x = volume_t, ymin = lwr, ymax = upr, group = ant_t, fill = as.factor(ant_t)), alpha = .2) 
  #geom_smooth(data=cactus, aes(y=repro_state_t, x=log(volume_t), col=ant_t), method = "glm", formula='y~x', method.args = list(family = "binomial"), se = TRUE)
  #geom_smooth(data = cactus, aes(x = log(volume_t), y = Survival_t1, pch = as.factor(ant_t)))
```


###Total Flowers

```{r}
#Model:
flower_model_ant_interact
#Simulated Data:
coefs <- mvrnorm(n = 10000, mu = coefficients(flower_model_ant_interact), Sigma = vcov(flower_model_ant_interact))

##Check this against original model
#Simulated Coefficients
colMeans(coefs)
#Original Coefficients
coefficients(flower_model_ant_interact)
#These are pretty similar, so I will now look at standard errors
#Simulated Standard Error
apply(coefs, 2, sd)
#Original Standard Error
sqrt(diag(vcov(flower_model_ant_interact)))
#These are also pretty good. So now we simulate the data

##simulate the data
sim.dat <- matrix(nrow = n, ncol = nrow(coefs))
mod.mat <- model.matrix(flower_model_ant_interact)
for (i in 1:nrow(coefs)) {
  sim.dat[, i] <- rpois(n, exp(mod.mat %*% coefs[i, ]))
}
rm(i, mod.mat)

##Now we compare the simualted and original variance and mean
#Simulated mean and var
c(mean(colMeans(sim.dat)), mean(apply(sim.dat, 2, var)))
#Original mean and var
c(mean(cactus$TotFlowerbuds_t,na.rm=TRUE), var(cactus$TotFlowerbuds_t,na.rm = TRUE))
```

Ok, So not perfect, but really not that bad!!!
## Visualize it!
```{r}
# This is were I run the model
# This is a gaussian model, but you can change the family to be poisson or whatever
flower_model_ant_interact
anova(flower_model_ant_interact, test = "Chisq")
summary(flower_model_ant_interact)
# plot(infl_mod)

# This is our simulated predictor data
min(cactus$volume_t, na.rm = T)
newdat1<- data.frame(volume_t = seq(log(0.1),log(3129321),0.002076463), ant_t = "crem")
newdat2 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "liom")
newdat3 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "vacant")
newdat4 <- data.frame(volume_t= seq(log(0.1),log(3129321),0.002076463), ant_t = "other")
newdat <- rbind(newdat1, newdat1, newdat2, newdat3)

# use the predict function for to get the model output
y_pred <- predict(flower_model_ant_interact, newdata = newdat, type = "response")
y_CI <- predict(flower_model_ant_interact, newdata = newdat, interval = "confidence", type = "link", se.fit=TRUE)

#This is one way to pull out the link function automatically from the fitted object
linkinv <- family(flower_model_ant_interact)$linkinv ## inverse-link function

# you can also define your own link function, which is useful for stuff like Stan, where you just get posterior draws, and not a R model object
# and so for my other project, where I have categorical data, I define these functions at the top of the script
# invlogit<-function(x){exp(x)/(1+exp(x))}
# and then use that transform the model predictions to the appropriate scale
# I think for poisson, you can use exp() to exponentiate the results

#Now make a dataframe that combines all the predictions and confidence intervals
newpred <- newdat
newpred$pred0 <- y_CI$fit
newpred$pred <- linkinv(y_CI$fit) #This is the link function
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
sc2 <- abs(qnorm((1-alpha2)/2))  ## Normal approx. to likelihood
newpred <- transform(newpred,
                     lwr=linkinv(pred0-sc*y_CI$se.fit),
                     upr=linkinv(pred0+sc*y_CI$se.fit),
                     lwr2=linkinv(pred0-sc2*y_CI$se.fit),
                     upr2=linkinv(pred0+sc2*y_CI$se.fit))

# Then you can plot it
ggplot() + 
  geom_point(data = cactus, aes(x = log(volume_t), y = TotFlowerbuds_t, pch = as.factor(ant_t)), color = "#4c90dd", lwd = 2) + 
  geom_line(data = newpred, aes(x = volume_t, y = pred, group = ant_t, linetype = as.factor(ant_t))) +
  geom_ribbon(data = newpred, aes(x = volume_t, ymin = lwr, ymax = upr, group = ant_t, fill = as.factor(ant_t)), alpha = .2) 
  #geom_smooth(data=cactus, aes(y=repro_state_t, x=log(volume_t), col=ant_t), method = "glm", formula='y~x', method.args = list(family = "binomial"), se = TRUE)
  #geom_smooth(data = cactus, aes(x = log(volume_t), y = Survival_t1, pch = as.factor(ant_t)))
```

###